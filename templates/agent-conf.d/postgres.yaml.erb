init_config:

instances:
#   -   host: localhost
#       port: 5432
#       username: my_username
#       password: my_password
#       dbname: db_name
#       tags:
#            - optional_tag1
#            - optional_tag2
#
  - host: <%= @host %>
    port: <%= @port %>
    username: <%= @username %>
    password: <%= @password %>
    dbname: <%= @dbname %>
<% if @tags and ! @tags.empty? -%>
    tags:
  <%- Array(@tags).each do |tag| -%>
    <%- if tag != '' -%>
      - <%= tag %>
    <%- end -%>
  <%- end -%>
<% end -%>

#  Custom-metrics section

#  You can now track per-relation (table) metrics
#  You need to specify the list. Each relation
#  generates a lot of metrics (10 + 10 per index)
#  so you want to only use the ones you really care about
#    relations:
#      - my_table
#      - my_other_table
<% if @tables and ! @tables.empty? -%>
    relations:
  <%- Array(@tables).each do |table| -%>
    <%- if table != '' -%>
        - <%= table %>
    <%- end -%>
  <%- end -%>
<% end -%>

# Custom metrics
# Below are some examples of commonly used metrics, which are implemented as custom metrics.
# Uncomment them if you want to use them as is, or use as an example for creating your own custom metrics.
# The format for describing custome metrics is identical with the one used for common metrics in postgres.py
# Be extra careful with ensuring proper custom metrics description format. If your custom metric does not work
# after an agent restart, look for errors in the otput of "/etc/init.d/datadog-agent info" command, as well as
# /var/log/datadog/collector.log file.
#
#    custom_metrics:
#   - # Londiste 3 replication lag
#     descriptors:
#       - [consumer_name, consumer_name]
#     metrics:
#        GREATEST(0, EXTRACT(EPOCH FROM lag)) as lag: [postgresql.londiste_lag, GAUGE]
#        GREATEST(0, EXTRACT(EPOCH FROM last_seen)) as last_seen: [postgresql.londiste_last_seen, GAUGE]
#        pending_events: [postgresql.londiste_pending_events, GAUGE]
#     query: SELECT  as consumer_name, %s from pgq.get_consumer_info() where consumer_name !~ 'watermark$';
#     relation: false

<% if @custom_metrics and ! Array(@custom_metrics).empty?  %>
    custom_metrics:
  <% if Array(@custom_metrics).include?('londiste3_replication')  %>
    - # Londiste 3 replication lag
      descriptors:
        - [consumer_name, consumer_name]
      metrics:
         GREATEST(0, EXTRACT(EPOCH FROM lag)) as lag: [postgresql.londiste_lag, GAUGE]
         GREATEST(0, EXTRACT(EPOCH FROM last_seen )) as last_seen: [postgresql.londiste_last_seen, GAUGE]
         pending_events: [postgresql.londiste_pending_events, GAUGE]
      query: SELECT consumer_name, %s from pgq.get_consumer_info() where consumer_name !~ 'watermark$';
      relation: false
  <% end -%>
  <% if Array(@custom_metrics).include?('tx_duration_92')  %>
    - # Max transaction and query duration for postgresql v9.2+
      descriptors: []
      metrics:
         GREATEST(0, EXTRACT(EPOCH FROM max(now()-xact_start))) as max_tx_duration: [postgresql.max_tx_duration, GAUGE]
         GREATEST(0, EXTRACT(EPOCH FROM max(case when state = 'active' then now() - query_start else interval '0 s' end))) as max_query_duration: [postgresql.max_query_duration, GAUGE]
      query: SELECT %s from pg_stat_activity where state != 'idle';
      relation: false
  <% end -%>
<% end -%>
